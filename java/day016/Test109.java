/* =====================================
■■■ 정렬(Sort) 알고리즘 ■■■
=====================================*/

// 향상된 버블 정렬(Bubble Sort)
//** 정렬하고자하는 대상 데이터가 어떤 형태를 띄고 있느냐에 따라 달라짐

// ※ 앞에서 본 Selection Sort(Test107.java)나 Bubble Sort(Test108.java)의 성능은 같다.
// (→ 성능에 대한 추정 근거: 반복문을 수행한 횟수)
// 하지만 향상된 Bubble Sort는 대상 데이터의 구조에 따라서
// 일반 Bubble Sort나 Selection Sort에  비해 성능이 좋을 수 있다.

// 원본 데이터: 61 15 20 22 30
//				15 20 22 30 61	- 1회전 (스왑 발생 → true) → 다음 회전 진행 ○
//				15 20 22 30 61	- 1회전 (스왑 발생 → false) → 다음 회전 진행 X

// ==> 1회전 수행... 2회전 수행... 을 해보니
//		2회전에서 스왑(자리바꿈)이 전혀 일어나지 않았기 때문에
// 불필요한 추가 연산(더 이상의 회전)은 무의미한 것으로 판단하여
// 수행하지 않는다.





// 실행 예)
// Source Data: 10 50 20 30 40
// Sorted Data: 10 20 30 40 50
// 계속하려면 아무 키나 누르세요...

public class Test109
{
	public static void main(String[] args)
	{
		//int[] a = {10, 50, 20, 30, 40};
		int[] a = {52, 42, 12, 62, 60};
		/*
			10, 50, 20, 30, 40
			==  --
			10, 50, 20, 30, 40
				==  --
			10, 20, 50, 30, 40
				==  --
			10, 20, 30, 50, 40
					==  --
			10, 20, 30, 40, 50
					==  --
			10, 20, 30, 40, 50
						==  --
			---------------------- 1회전 → 스왑발생 O
			10, 20, 30, 40, 50
			==  --
			10, 20, 30, 40, 50
				==  --
			10, 20, 30, 40, 50
					==  --
			---------------------- 2회전 → 스왑발생 X
				X
			---------------------- 3회전 →  X
				X
			---------------------- 4회전 →  X

		*/
		System.out.printf("Source Data: ");
		for (int n: a )
			System.out.print(n + " ");
		System.out.println();
		// 내가 푼 내용 --------------------------
		/*
		int i,j;
		boolean check = false;	// 바뀌었는지 여부 체크

		
		for (i=1;i<a.length ;i++ )
		{
			for(j=0; j<a.length-i; j++)
			{			
				if(a[j] > a[j+1])
				{	
					//자리바꿈
					a[j]	= a[j] ^ a[j+1];
					a[j+1]	= a[j+1] ^ a[j];
					a[j]	= a[j] ^ a[j+1];
					check = true;
				}
			}

			if(check == false)
				break;

			check = false;		// 한번이 아니라 여러번 바뀌었는지 체크하기 위해
		}
		*/

		// 함께 푼 내용 --------------------------
		boolean flag;
		int pass =0;

		do	// 10 20 30 40 50 - 처음부터 정렬이 되어있더라도 크기비교를 1번 확인하기 위해
		{	
			flag = false;		//-- 이번 회전에서 자리바꿈 발생X
								//-- 밖에서 초기화하면 안됨
			pass++;
			for (int i=0; i<a.length-pass; i++)
			{
				// 테스트
				//System.out.println("쑝");

				if(a[i] > a[i+1])	// 오름차순
				{
					// 자리 바꿈
					a[i]	= a[i] ^ a[i+1];
					a[i+1]	= a[i+1] ^ a[i];
					a[i]	= a[i] ^ a[i+1];

					flag = true;
					//-- 단 한번이라도 스왑(자리바꿈)이 발생하게 되면
					// flag 변수는 true로 변경
				}
			}
		}
		while (flag);
		//-- flag 변수가 false라는 것은
		//	회전이 구분적으로 발생하는 동안 스왑이 일어나지 않는 경우로
		//	더 이상 반복문 수행은 무의미한 것으로 판단 가능~!!!

		// 결과 출력
		System.out.printf("Sorted Data: ");
		for (int n: a )
			System.out.print(n + " ");
		System.out.println();
	}
}
// 실행 결과
/*
Source Data: 10 50 20 30 40
Sorted Data: 10 20 30 40 50
*/