
# 페이지 20231103_01_scott(qlsql).sql
## 1. 문제
--○ 임의의 정수 두 개를 매개변수(입력 파라미터)로 넘겨받아 -> (A,B)  
--   A 의 B 승의 값을 반환하는 사용자 정의 함수를 작성한다.  
--   단, 기존의 오라클 내장 함수를 이용하지 않고, 반복문을 활용하여 작성한다.  
-- 함수명 : FN_POW()  
/*
사용 예)
SELECT FN_POW(10,3)
FROM DUAL;
--==>> 1000
*/
### 1.2. 답
``` SQL
CREATE OR REPLACE FUNCTION FN_POW(V_N1 NUMBER, V_N2 NUMBER)
RETURN NUMBER
IS
    -- 선언부
    V_I      NUMBER := 1;   -- 증가변수
    V_RESULT NUMBER := V_N1;-- 결과값
BEGIN
    -- 실행부    
    LOOP
        EXIT WHEN V_I >= V_N2;
        V_RESULT := V_RESULT * V_N1;
        V_I := V_I + 1;
    END LOOP;
    
    -- 결과값 반환
    RETURN V_RESULT;
END;
--==>> Function FN_POW이(가) 컴파일되었습니다.
```
### 1.3. 해설
``` SQL
/*
FN_POW(10,3)
    기준 1 * 10 * 10 * 10 -> 1000 -(O)
    기준 0 * 10 * 10 * 10 -> 0    -(X)
*/
CREATE OR REPLACE FUNCTION FN_POW(A NUMBER, B NUMBER)
RETURN NUMBER
IS
    V_RESULT    NUMBER := 1;    -- 반환 결과값 변수 -> 1로 초기화~!!! CHECK~!!!
    V_NUM       NUMBER;         -- 루프 변수
BEGIN
    -- 반복문 구성
    FOR V_NUM IN 1 .. B LOOP
        V_RESULT := V_RESULT * A;   -- V_RESULT *= A;
    END LOOP;
    
    -- 최종 결과값 반환
    RETURN V_RESULT;
END;
--==>> Function FN_POW이(가) 컴파일되었습니다.
-- *PLSQL의 경우 컴파일 되었다고 해서, 로직이 문제가 없다는 것은 아님*  
```
## 2. 문제
--○ TBL_INSA 테이블의 급여 계산 전용 함수를 정의한다.  
--   급여는 <(기본급*12)+수당> 기반으로 연산을 수행한다.  
-- 함수명: FN_PAY(기본급, 수당)  

--BASICPAY
--SUDANG
### 2.2. 답
``` SQL
CREATE OR REPLACE FUNCTION FN_PAY(V_BPAY NUMBER, V_SUDANG NUMBER)
RETURN NUMBER
IS
    V_RESULT NUMBER;
BEGIN
    V_RESULT := V_BPAY*12 + V_SUDANG;
    
    RETURN V_RESULT;
END;
--==>> Function FN_PAY이(가) 컴파일되었습니다.
```
### 2.3. 해설
``` SQL
CREATE OR REPLACE FUNCTION FN_PAY(VBASICPAY NUMBER, VSUDANG NUMBER)
RETURN NUMBER
IS
    -- 주요 변수 선언
    VRESULT NUMBER;
BEGIN
    -- 연산 및 처리
    VRESULT := (NVL(VBASICPAY,0)*12) + NVL(VSUDANG,0);
    
    -- 최종 결과값 반환
    RETURN VRESULT;
END;
--==>> Function FN_PAY이(가) 컴파일되었습니다.

-- *기본급 누락, 수락 누락 등이 있으면 -> NULL*  
-- *따라서, 안정적이기 위해 NULL을 고려해 연산 및 처리 하기*  
```
## 3. 문제
--○ TBL_INSA 테이블에서
--   입사일을 기준으로 현재까지 근무년수를 반환하는 함수를 정의한다.
--   단, 근무년수는 소수점 이하 한자리까지 계산한다.
-- 함수명: FN_WORKYEAR(입사일)
>-- *현재의 기준은 내년에 조회하더라도 가능하도록* 

--IBSADATE: 입사일
### 3.2. 답
``` SQL
CREATE OR REPLACE FUNCTION FN_WORKYEAR(VIBSADATE DATE)
RETURN VARCHAR2
IS
    V_RESULT NUMBER;
    V_RESULT2 VARCHAR2(20);
BEGIN
    V_RESULT := TRUNC(MONTHS_BETWEEN(SYSDATE,VIBSADATE)/12,1);
    V_RESULT2 := (TO_CHAR(V_RESULT) ||'='||TRUNC(V_RESULT)||'년'||MOD(V_RESULT,1)*12||'개월');
    
    V_RESULT2 := (TO_CHAR(TRUNC(MONTHS_BETWEEN(SYSDATE,VIBSADATE)/12))||'년')
                 ||(TO_CHAR(TRUNC(MOD(MONTHS_BETWEEN(SYSDATE,VIBSADATE),12)))||'개월');
                 
    RETURN V_RESULT2;
END;
--==>> Function FN_WORKYEAR이(가) 컴파일되었습니다.

```
### 3.3. 해설
``` SQL
-- 1
SELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('1998-10-11','YYYY-MM-DD'))/12 "RESULT"
FROM DUAL;
--==>> 25.06314046321186778176025487853444842692

-- 2
SELECT TRUNC(MONTHS_BETWEEN(SYSDATE, TO_DATE('1998-10-11','YYYY-MM-DD'))/12) || '년' ||
        TRUNC(MOD(MONTHS_BETWEEN(SYSDATE, TO_DATE('1998-10-11','YYYY-MM-DD')),12)) || '개월'
FROM DUAL;
--==>> 25년0개월

-- 3: 년의 소수점 첫째자리까지
CREATE OR REPLACE FUNCTION FN_WORKYEAR(VIBSADATE DATE)
RETURN NUMBER
IS 
    VRESULT NUMBER;
BEGIN
    VRESULT := TRUNC(MONTHS_BETWEEN(SYSDATE, VIBSADATE) / 12 ,1);
    
    RETURN VRESULT;
END;

-- 4: X년 X개월
CREATE OR REPLACE FUNCTION FN_WORKYEAR(VIBSADATE DATE)
RETURN VARCHAR2
IS 
    VRESULT VARCHAR2(20);
BEGIN
    VRESULT := TRUNC(MONTHS_BETWEEN(SYSDATE, VIBSADATE) / 12) || '년' ||
               TRUNC(MOD(MONTHS_BETWEEN(SYSDATE,VIBSADATE),12))||'개월';
    
    RETURN VRESULT;
END;
```
## 4. 문제
--
### 4.1. 답
``` SQL

```
### 4.3. 해설
``` SQL

```
## 5. 문제
--
### 5.2. 답
``` SQL

```
### 5.3. 해설
``` SQL

```
## 6. 문제
--
### 6.2. 답
``` SQL

```
### 6.3. 해설
``` SQL

```

<BR>

# 페이지 20231103_02_scott.sql
## 📌 1. 안내

## 1. 문제
--
### 1.2. 답
``` SQL

```
### 1.3. 해설
``` SQL

```
## 2. 문제
--
### 2.2. 답
``` SQL

```
### 2.3. 해설
``` SQL

```
## 3. 문제
--
### 3.2. 답
``` SQL

```
### 3.3. 해설
``` SQL

```
## 4. 문제
--
### 4.1. 답
``` SQL

```
### 4.3. 해설
``` SQL

```
## 5. 문제
--
### 5.2. 답
``` SQL

```
### 5.3. 해설
``` SQL

```
## 6. 문제
--
### 6.2. 답
``` SQL

```
### 6.3. 해설
``` SQL

```
