# 8. 정규화(Normalization)
-- *웹 개발자관점에서 중요도는 낮지만, FINAL PJ에서 가장 핵심이 되는 부분이고 DBA에게 정말 중요하다!!!*  
--○ 정규화란?  
--   한 마디로 데이터베이스 서버의 메모리 낭비를 막기 위해  
--   어떤 하나의 테이블을... 식별자를 가지는 여러 개의 테이블로 **나누는 과정**을 말한다. 
  
-- *특정컬럼 값이 필요할때 테이블을 가져다 쓸텐데, 메모리는 특정값만 가져오는게 아니라 테이블 전체를 퍼올리기 때문에*  
-- *테이블이 작을 수록 메모리 낭비가 적어진다.*  
  
-- ex) 윤수가... 옥장판을 판매한다.  
--     고객리스트 -> 거래처 직원 명단이 적혀있는 수첩의 정보를 데이터베이스화 하려고 한다.

``` SQL
-- 테이블명: 거래처직원  
    10Byte    10Byte        10Byte      10Byte       10Byte 10Byte  10Byte
--------------------------------------------------------------------------------
거래처회사명  회사주소     회사전화     거래처직원명  직급  이메일   휴대폰
--------------------------------------------------------------------------------
    LG        서울여의도   02-345-6789   최혜인       부장  chi@na... 010-23...      
    LG        서울여의도   02-345-6789   채다선       과장  cds@da... 010-76...      
    LG        서울여의도   02-345-6789   정현욱       대리  chy@da... 010-98...      
    LG        서울여의도   02-345-6789   정한울       부장  chw@na... 010-39...      
    SK        서울소공동   02-987-6543   임하성       부장  lhs@na... 010-12...      
    LG        부산동래구   051-221-2211  이주형       대리  ljh@em... 010-55...      
    SK        서울소공동   02-987-6543   오수경       과장  osk@na... 010-88...     
                                            :
--------------------------------------------------------------------------------
```

**가정)** 서울 여의도 LG(본사)라는 회사에 근무하는 거래처 직원 명단이 총 100만 명이라고 가정한다.  
(한 행(레코드)은 70Byte)  
어느 날... <서울여의도>에 위치한 LG 본사가 <경기분당>으로 사옥을 이전하게 되었다.  
회사주소는 <경기분당>으로 바뀌고, 회사전화는 <031-111-2222>로 바뀌게 되었다.       
그러면... 100만 명의 회사주소와 회사전화를 변경해야 한다.          
-- 이 때 수행되어야 할 쿼리문 -> UPDATE  
      
``` SQL
      UPDATE 거래처직원  
      SET 회사주소 = '경기분당', 회사전화 = '031-111-2222'  
      WHERE 거래처회사명 = 'LG' AND 회사주소 = '서울여의도';  
```
-- 100만 개 행을 하드디스크상에서 읽어서 메모리에 로드시켜 주어야 한다.  
         즉, 100만 * 70Byte 를 모두  
         하드디스크상에서 읽어서 메모리에 로드시켜 주어야 한다는 말이다.  
         
-> 이는 테이블의 설계가 잘못되었으므로 DB 서버는 조만간 메모리 고갈로 인해 DOWN 될 것이다.  
-> 그러므로 정규화 과정을 수행해야 한다.  
 
>-- *여러가지 정규화(제7정규형까지, 제6정규형까지..)가 있지만, 우리는 실무를 기준으로 정규화를 볼 예정*   
## 8.1. 제 1 정규화(형)  
--> 어떤 하나의 테이블에 반복되는 컬럼 값들이 존재한다면  
--  값들이 **반복되어 나오는 컬럼**을 **분리**하여 새로운 테이블을 만들어준다.  
    
```SQL
-- 테이블명 : 회사 -> 부모테이블(참조받는 테이블)  
10Byte     10Byte       10Byte        10Byte      
-------------------------------------------------  
회사ID    거래처회사명  회사주소     회사전화  
+++++++
참조받는 컬럼
------------------------------------------------- 
10            LG        서울여의도   02-345-6789         
20            LG        부산동래구   051-221-2211         
30            SK        서울소공동   02-987-6543       
------------------------------------------------- 
-- [무결성]회사ID는 하나만 이어야하고, 비어있으면 안됨  
```
```SQL 
-- 테이블명 : 직원 -> 자식테이블(참조하는 테이블)  
10Byte       10Byte 10Byte  10Byte      10Byte  
------------------------------------------------  
거래처직원명  직급  이메일   휴대폰      회사ID  
                                        ========
                                        참조하는 컬럼
------------------------------------------------  
최혜인       부장  chi@na... 010-23...   10  
채다선       과장  cds@da... 010-76...   10  
정현욱       대리  chy@da... 010-98...   10  
정한울       부장  chw@na... 010-39...   10  
임하성       부장  lhs@na... 010-12...   20  
이주형       대리  ljh@em... 010-55...   30  
오수경       과장  osk@na... 010-88...   10  
------------------------------------------------  
```
--> 제 1 정규화를 수행하는 과정에서 분리된 테이블은 반드시 부모테이블과 자식 테이블이 관계를 갖게 된다.  
>-- *무결성: 결점이 없다.*  
-- *관계형 DB의 경우 특정한 부분에서 결점이 있다고 하더라도, 참조하고 있는 테이블이 있기 때문에 전반적으로 신뢰성이 떨어진다.*  
```SQL
                                    -- 제약조건
    --> 부모 테이블 -> 참조받는 컬럼 -> PRIMARY KEY(기본키, 고유키)
    --  자식 테이블 -> 참조하는 컬럼 -> FOREIGN KEY(외래키, 참조키)
```
--※ 참조받는 컬럼이 갖는 특징  
--   반드시 고유한 값(데이터)만 들어와야 한다. 즉, 중복된 값(데이터)이 있어서는 안된다.  
--   또한, 비어있으면(NULL이 있어서는) 안된다. 즉, NOT NULL 이어야 한다.  
    
--> 제 1 정규화를 수행하는 과정에서 부모테이블의 PRIMARY KEY 는 항상 자식 테이블의 FOREIGN KEY 로 전이된다.  
    
>-- *========================================================================*  
    -- *결론: 정규화는 쪼개는 것*  
    -- *제 1 정규화는 반복된 내용을 쪼개는 것이다.*  
    -- *부모테이블에는 참조받는 컬럼(PRIMARY KEY,중복x,비어있음x)*  
    -- *자식테이블에는 참조하는 컬럼(부모의 PK를 참조하는 FOREIGN KEY)*  
    -- *========================================================================*
    
-- 테이블이 분리(분할)되기 이전 상태로 조회  
>-- *JOIN을 통해서 조회*  
``` SQL
    SELECT A.거래처회사명, A.회사주소, A.회사전화
         , B.거래처직원명, B.직급, B.이메일, B.휴대폰
    FROM 회사 A, 직원 B
    WHERE A.회사ID = B.회사ID;
```
    
**가정)** 서울 여의도 LG(본사)라는 회사에 근무하는 거래처 직원 명단이 총 100만 명이라고 가정한다.  
-- [삭제](한 행(레코드)은 70Byte)  

어느 날... <서울여의도>에 위치한 LG 본사가 <경기분당>으로 사옥을 이전하게 되었다.  
회사주소는 <경기분당>으로 바뀌고, 회사전화는 <031-111-2222>로 바뀌게 되었다.  

-- [수정전]그러면... 100만 명의 회사주소와 회사전화를 변경해야 한다.  
**-- [수정후]그러면... 회사 1건의 회사주소와 회사전화를 변경해야 한다.** 

-- 이 때 수행되어야 할 쿼리문 -> UPDATE  
```SQL
-- [수정전]
UPDATE 거래처직원  
SET 회사주소 = '경기분당', 회사전화 = '031-111-2222'  
WHERE 거래처회사명 = 'LG' AND 회사주소 = '서울여의도';  
--                    ↓
-- [수정후]
UPDATE 회사
SET 회사주소 = '경기분당', 회사번화 = '031-111-2222'
WHERE 회사ID = 10;
```
-- [수정전]100만 개 행을 하드디스크상에서 읽어서 메모리에 로드시켜 주어야 한다.  
-- [수정후]1 개 행을 하드디스크상에서 읽어서 메모리에 로드시켜 주어야 한다.  
 [수정전]즉, 100만 * 70 Byte 를 모두  
 [수정후]즉, 1 * 40 Byte 를 모두  
 하드디스크상에서 읽어서 메모리에 로드시켜 주어야 한다는 말이다.  
 
 -> 정규화 이전에는 100만 건을 처리해야 할 업무에서
    1건만 처리하면 되는 업무로 바뀐 상황이기 때문에
    DB 서버는 메모리 고갈이 일어나지 않고 아주 빠르게 처리될 것이다.
``` SQL    
--      [정규화 이후]                 |         [정규화 이전]
-- 거래처회사명, 회사전화 
SELECT 거래처회사명, 회사전화         | SELECT 거래처회사명, 회사전화
FROM 회사;                            | FROM 거래처직원;
--> 3*40 Byte                         | --> 200만*70 Byte

-- 거래처직원명, 직급
SELECT 거래처직원명, 직급             | SELECT 거래처직원명, 직급
FROM 직원;                            | FROM 직원;
--> 200만*50 Byte                     | --> 200만*70 Byte

-- 거래처회사명, 거래처직원명
SELECT 거래처회사명, 거래처직원명     | SELECT 거래처회사명, 거래처직원명
FROM 회사 A JOIN 직원 B               | FROM 거래처직원;
ON A.회사ID = B.회사ID                | 
--> (3*40) + (200만*50) Byte          | --> 200만*70 Byte
--==>> 3개의 경우 모두 정규화 이전의 Byte 가 작음
```

``` SQL    
-- 테이블명 : 주문
--------------------------------------------------------------------------------
    고객ID        제품코드        주문일자            주문수량
    ++++++++++++++++++++++++++++++++++++++
                    P.K
--------------------------------------------------------------------------------
    UJY1234(엄재용)     P-KKBK(꿀꽈배기)  2023-10-30 07:20:31     20
    PBK8835(박범구)     P-KKBC(꼬북칩)    2023-10-30 07:21:40     20
    PNY3235(박나영)     P-KKDS(쿠크다스)  2023-10-30 08:10:10     13
    PKY5834(박가영)     P-SWKK(새우깡)    2023-10-30 09:07:04     12
                                        :
--------------------------------------------------------------------------------
```
### (페이지 20231030_01_hr.sql)
#### 1. 문제
-- 위의 주문 테이블에서 PK로 해야하는 키는?  
-- 고객ID   일 경우: 고객1이 더이상 구매X  
-- 제품코드 일 경우: 제품코드1이 더이상 판매X  
-- 고객ID + 제품코드 일 경우: 고객이 제품을 한번밖에 구매못함  
-- 고객ID + 제품코드 + 주문일자 일 경우: 같은값 2개 일때?  

``` SQL
    -- UJY1234(엄재용)     P-KKBK(꿀꽈배기)  2023-10-30 07:20:31     20
    -- UJY1234(엄재용)     P-KKBK(꿀꽈배기)  2023-10-30 07:20:31     20
    --------------------------------------------------------------------
    -- UJY1234(엄재용)     P-KKBK(꿀꽈배기)  2023-10-30 07:20:31     40 -> 으로 구성되기 때문에 3개로 복합 PK 가능
```
>-- *PK는 1개만 가능*  
-- *제약조건을 구성하는 컬럼은 여러개가 될 수 있음*  
 
-- ※ 하나의 테이블에 존재하는 PRIMARY KEY 의 최대 갯수는 1개이다.  
--    하지만, PRIMARY KEY 를 이루는(구성하는) 컬럼의 갯수는 복수(여러개)인 것이 가능하다.  
--    컬럼 1개로만 구성된 PRIMARY KEY 를 SINGLE PRIMARY KEY 라고 부른다.  
--    (단일 프라이머리 키)  
--    두 개 이상의 컬럼으로 구성된 PRIMARY KEY 를 COMPOSITE PRIMARY KEY 라고 부른다.  
--    (복합 프라이머리 키)  
>-- *복합 프라이머리 키는 개념적으론 가능하나, 권장하지는 않음*  
## 8.2. 제 2 정규화(형)  

## 8.3. 제 3 정규화(형)  

## 8.4. 제 4 정규화(형)  

## 8.5. 역정규화(비정규형)  

## 📌 1. 안내















